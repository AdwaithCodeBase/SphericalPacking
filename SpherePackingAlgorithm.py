# IMPORTING RUDIMENTARY LIBRARIES
import time
import math
import numpy as np
import warnings
warnings.filterwarnings("ignore")
import pyvista as pv
from numba import jit

# CONSTANTS
PI = math.pi


@jit(nopython=True)
def GenHardSpheres(Rsphere,Lst,Lend,Rin,Rout,MCno):
    
    ''' =======================================================================
                             Model summary: Generate Monte Carlo hard iron spheres of FIXED RADIUS 
                             inside iron domain 

                             INPUT -----
                             Rsphere:     Iron Sphere Radius [mm]
                             Lcylinder :    Length of the iron cylinder [mm]
                             Rin:        Inside radius of iron cylinder [mm]
                             Rout:       Outside radius of iron cylinder [mm]
                             MCno :      total maximum number of  Monte Carlo spheres 
                             [Final number can be lesser then this value]

                             OUTPPUT -----
                             D:       Coordinates of Spheres in Domain [mm]
                             R:       Radius of Spheres in Domain- constant in this case [mm]

                            REQUIRED LIBRARIES:
                            import numpy as np
                            import time
                            import math
                            from numba import jit
                            import warnings
                            warnings.filterwarnings("ignore")

                         ========================================================================'''

    radius = np.random.uniform(0, 1, MCno) * (Rout - Rin) + Rin
    theta = 2 * math.pi * np.random.uniform(0, 1, MCno)
    IronData = np.zeros((MCno, 3))
    IronData[:, 1] = radius * np.cos(theta)
    IronData[:, 2] = radius * np.sin(theta)
    IronData[:, 0] = np.random.uniform(0, 1, MCno) * (Lend - Lst) + Lst

    MC = IronData.copy()
    MasterLattice = np.zeros((MCno,3))
    Raccum = np.zeros(MCno)

    MasterLattice[0,:] = MC[0,:]
    Raccum[0] = Rsphere

    ed = 1
    for i in range(1,MCno):
        distv = MC[i, :] - MasterLattice[0:ed,:]
        distSQ = np.sqrt((distv[:, 0] * distv[:, 0]) + (distv[:, 1] * distv[:, 1]) + (distv[:, 2] * distv[:, 2]))
        mask0 = np.array([(radius[i] + Rsphere > Rout) | (radius[i] - Rsphere < Rin)]) |\
                (MC[i, 0] - Rsphere < Lst) | (MC[i, 0] + Rsphere > Lend)
        if True in mask0:
            continue

        mask1 = (distSQ < 2 * Raccum[0:ed])
        if True in mask1:
            pass
            mask2 = (distSQ < Raccum[0:ed])
            if True in mask2:
                pass
            else:
                MasterLattice[ed,:] = MC[i, :]
                ind = (np.where(distSQ == np.amin(distSQ)))[0][0]
                d0 = distSQ[ind] - Raccum[ind]
                rval = math.sqrt(MC[i, 1]**2+MC[i, 2]**2)
                d1 = Rout - rval
                d2 = rval - Rin
                d3 = abs(Lst - MC[i, 0])
                d4 = abs(Lend - MC[i, 0])
                Rnew = min(d0,d1,d2,d3,d4)
                Raccum[ed] = Rnew
                ed +=1
        else:
            MasterLattice[ed,:] = MC[i, :]
            Raccum[ed] = Rsphere
            ed += 1

    return MasterLattice,Raccum


@jit(nopython=True)
def RandomWalkSpherePacking(Data,Raccum,Rin,Rout,Lst,Led,r,RWnumb):
    
    ''' =======================================================================
                             Model summary: Generate Monte Carlo iron spheres of VARIABLE RADIUS 
                             inside iron domain by randomly walking in space inbetween hard spheres of 
                             fixed radius 

                             INPUT -----
                             Data:        Location of Hard Spheres in iron domain [mm]
                             Raccum:      Radius array of hard spheres in iron domain  [mm]
                             L :         Length of the iron cylinder [mm]
                             Rin:        Inside radius of iron cylinder [mm]
                             Rout:       Outside radius of iron cylinder [mm]
                             r:          Iron Sphere Radius [mm]
                             
                             RWnumb:     Total number of random walks to take inside the domain 
                             to fill domain with iron spheres
                             This value affects the resutling total number of iron spheres generated by the end of this 
                             process
                             
                             RWsize :    Maximum step length to take during the course of the random 
                             walk in the iron domain [mm]
                             This determines the distribution of the resulting monte carlo iron spheres

                             OUTPPUT -----
                             RWData:       Coordinates of Spheres in Domain [mm]
                             RWradius:     Radius of Spheres in Domain- constant in this case [mm]

                            REQUIRED LIBRARIES:
                            import numpy as np
                            import time
                            import math
                            from numba import jit
                            import warnings
                            warnings.filterwarnings("ignore")

                         ========================================================================'''

    RWdx = abs(Led - Lst)/2
    RWdy = (Rout - Rin)/2
    RWdz = RWdy

    rv = (np.random.rand()) * ((Rout-r) - (Rin+r)) + (Rin+r)
    tv = 2 * math.pi * np.random.rand()
    yw = rv * np.cos(tv)
    zw = rv * np.sin(tv)
    xw = np.random.rand() * (Led - Lst) + Lst

    RWData = np.concatenate((Data,np.zeros((RWnumb,3))),axis=0)
    RWradius = np.concatenate((Raccum,np.zeros(RWnumb)))

    st = len(Raccum)
    CPt = np.zeros((1, 3))
    for i in range(RWnumb):
        CPt[0,0] = xw; CPt[0,1] = yw; CPt[0,2] = zw
        distv = CPt - RWData[0:st,:]
        distSQ = np.sqrt((distv[:, 0] * distv[:, 0]) + (distv[:, 1] * distv[:, 1])+ (distv[:, 2] * distv[:, 2]))
        mask = distSQ < RWradius[0:st]
        if True in mask:
            pass
        else:
            """"ADDING COORDINATE LOCATION TO GLOBAL ARRAY"""
            RWData[st,:] = CPt[0,:]

            """"ADDING DISTANCE TO BOUNDARIES"""
            Bounddist = np.abs((CPt[0,1]**2+CPt[0,2]**2)**0.5 - np.array([Rin,Rout]))
            Bounddist = np.append(Bounddist,[abs(Lst - CPt[0, 0]),abs(Led - CPt[0, 0])])
            distSQ = np.append(distSQ,Bounddist)
            RWradius = np.append(RWradius,np.zeros(3))

            """"FINDING MINIMUM DISTANCE AMONG ALL DISTANCES"""
            ind = np.where(distSQ == np.amin(distSQ))[0][0]
            Rnew = distSQ[ind] - RWradius[ind]
            if Rnew > r:
                Rnew = r

            """"ADDING RADIUS TO GLOBAL ARRAY"""
            RWradius[st] = Rnew
            st +=1

        xw += np.random.rand() * RWdx
        yw += np.random.rand() * RWdy
        zw += np.random.rand() * RWdz

        rad = math.sqrt(yw**2 + zw**2)
        cnt = 0
        while (rad + r > Rout) | (rad - r < Rin) | (xw - r < Lst) | (xw + r > Led):
            xw -= RWdx/2
            yw -= RWdy/2
            zw -= RWdz/2
            rad = math.sqrt(yw ** 2 + zw ** 2)
            cnt +=1
            if cnt > 10:
                rv = (np.random.rand()) * ((Rout - r) - (Rin + r)) + (Rin + r)
                tv = 2 * math.pi * np.random.rand()
                yw = rv * np.cos(tv)
                zw = rv * np.sin(tv)
                xw = np.random.rand() * (Led - Lst) + Lst
                break

    RWradius *= 1.25

    return RWData, RWradius


def DataUpdate(Darr,Rarr):
    return Darr[~np.all(Darr == 0, axis=1)],Rarr[Rarr != 0]


def MonteCarloSpherePack(RWsize,Radfer,Lstart,Lend,MCno,Rst,Rar):

    ''' =======================================================================
                             Generate Monte Carlo Randomly distributed hard spheres inside cylindrical volume
                             Model summary: Random Walking Sphere Packing;
                             Two step process:
                             First step: Fill domain with maximum sized hard spheres
                             Second step: Fill domain with spheres of variables size based on a random walking approach

                             INPUT -----
                             RWsize:       Size of Random walk inside domain [mm]; Roughly 1/4 of domain length
                             Radfe :      Maximum radius of hard spheres inside domain [mm]
                             Lval :      Domain length  [mm]

                             RWnumb:     Total number of random walks to take inside domain to fill with sphere;
                             Spheres are added every other random walking step
                             This variables also determines maximum number of initial hard spheres

                             Rst: Starting Radius [mm]; Could be both inner or outer radius in the case of annular cylinder
                             Above choice determined based on sphere refinement i.e. if refinement needs to be provided
                             close to inner radius then Rst --> Outer radius and vice versa

                             Rar: Radius array; Array containing transition radius where sphere refinement changes
                             This array helps to change sphere density in deffierent zones of annular cylinder
                             This is especially usefull for AC simulations with field penetration upto skin depth


                             OUTPPUT -----
                             D:       Coordinates of Spheres in Domain [mm]
                             R:       Radius of Spheres in Domain [mm]

                             REQUIRED LIBRARIES:
                             import numpy as np
                             import time
                            import math
                            from numba import jit
                            import warnings
                            warnings.filterwarnings("ignore")

                         ========================================================================'''
    print("")
    print('>>>STARTING MONTE CARLO SPHERE PACKING<<<<<')

    t0 = time.time()
    MCorg = np.sum(MCno)
    R1 = Rst
    D = np.zeros((1,3))
    R = np.empty([0])
    HPAccumno = 0
    RWAccumno = 0
    print(f'Total number of MC Spheres requested: {2*MCorg * len(Rar)}')
    for i in range(len(Rar)):
        R2 = Rar[i]
        Radfe = Radfer[i]
        Data, Rarray = GenHardSpheres(Radfe, Lstart,Lend, R2, R1, MCno[i]) # R1 > R2
        Data, Rarray = DataUpdate(Data, Rarray)
        HPno = len(Data)
        HPAccumno += HPno

        RWnumb = MCno[i]
        Data, Rarray = RandomWalkSpherePacking(Data, Rarray, R2, R1, Lstart,Lend, Radfe, RWnumb) # R1 > R2
        Data, Rarray = DataUpdate(Data, Rarray)
        RWno = len(Data) - HPno
        RWAccumno += RWno

        print(f'Total number of MC Spheres Generated for layer {i+1}: {HPno+RWno}')

        D = np.append(D,Data,axis=0)
        R = np.append(R,Rarray)

        R1 = R2 + 0.5 * (R1-R2)
        # MCno = int(MCno/1.5)
        # Radfe *= 2

    D = np.delete(D,0,0)

    print(f'Total number of MC Spheres Generated by Hard Packing: {HPAccumno}')
    print(f'Total point loss during Hard Packing: {round((((len(Rar)*MCorg) - HPAccumno) / (len(Rar)*MCorg)) * 100,2)} %')
    print(f'Total number of MC Spheres Generated by Random Walking: {RWAccumno}')
    print(f'TOTAL NO OF MC SPHERES GENERATED IN DOMAIN: {RWAccumno+HPAccumno}')
    
    SphVol = np.sum((4 / 3) * PI * R ** 3)
    CylVol = PI * (Rst ** 2 - min(Rar) ** 2) * abs(Lend - Lstart)
    ActualPackingFactor = SphVol / CylVol
    print(f'Actual Packing factor {round(ActualPackingFactor,2)}')
    print(f'>>> MONTE CARLO SPHERE PACKING COMPLETED IN: {round(time.time()-t0,2)} s<<<<<')
    print("")
    
    return D,R


def DCMonteCarloSpherePack(Radfer, Lstart,Lend, MCno, Rout, Rin,display):
    ''' =======================================================================
                             Generate Monte Carlo Randomly distributed hard spheres inside cylindrical volume
                             Model summary: Random Walking Sphere Packing;
                             Two step process:
                             First step: Fill domain with maximum sized hard spheres
                             Second step: Fill domain with spheres of variables size based on a random walking approach

                             INPUT -----
                             RWsize:       Size of Random walk inside domain [mm]; Roughly 1/4 of domain length
                             Radfe :      Maximum radius of hard spheres inside domain [mm]
                             Lval :      Domain length  [mm]

                             RWnumb:     Total number of random walks to take inside domain to fill with sphere;
                             Spheres are added every other random walking step
                             This variables also determines maximum number of initial hard spheres

                             Rst: Starting Radius [mm]; Could be both inner or outer radius in the case of annular cylinder
                             Above choice determined based on sphere refinement i.e. if refinement needs to be provided
                             close to inner radius then Rst --> Outer radius and vice versa

                             Rar: Radius array; Array containing transition radius where sphere refinement changes
                             This array helps to change sphere density in deffierent zones of annular cylinder
                             This is especially usefull for AC simulations with field penetration upto skin depth


                             OUTPPUT -----
                             D:       Coordinates of Spheres in Domain [mm]
                             R:       Radius of Spheres in Domain [mm]

                             REQUIRED LIBRARIES:
                             import numpy as np
                             import time
                            import math
                            from numba import jit
                            import warnings
                            warnings.filterwarnings("ignore")

                         ========================================================================'''
    print("")
    print('>>>STARTING MONTE CARLO SPHERE PACKING<<<<<')

    t0 = time.time()
    MCorg = np.sum(MCno)
    D = np.zeros((1, 3))
    R = np.empty([0])
    HPAccumno = 0
    RWAccumno = 0

    if display ==1:
        print(f'Total number of MC Spheres requested: {2 * MCorg }')

    Data, Rarray = GenHardSpheres(Radfer, Lstart,Lend, Rin, Rout, MCno)  # R1 > R2
    Data, Rarray = DataUpdate(Data, Rarray)
    DataH = Data.copy()
    RH = Rarray.copy()

    HPno = len(Data)
    HPAccumno += HPno

    RWnumb = MCno
    Data, Rarray = RandomWalkSpherePacking(Data, Rarray, Rin, Rout, Lstart,Lend, Radfer, RWnumb)  # R1 > R2
    Data, Rarray = DataUpdate(Data, Rarray)

    # pv.set_plot_theme('document')
    # p = pv.Plotter()
    # Corems = pv.PolyData(Data)
    # Corems["radius"] = np.ones(len(Data)) * 1
    # geom = pv.Sphere(theta_resolution=20, phi_resolution=20)
    # glyphed = Corems.glyph(scale="radius", geom=geom, )  # progress_bar=True)
    # p.add_mesh(glyphed, render_points_as_spheres=True, color='#878787')
    #
    # Coren = pv.PolyData(DataH)
    # Coren["radius"] = np.ones(len(DataH)) * 1.5
    # glyphed = Coren.glyph(scale="radius", geom=geom, )  # progress_bar=True)
    # p.add_mesh(glyphed, render_points_as_spheres=True, color='red')
    # p.show()

    RWno = len(Data) - HPno
    RWAccumno += RWno

    if display == 1:
        print(f'Total number of MC Spheres Generated : {HPno + RWno}')

    D = np.append(D, Data, axis=0)
    R = np.append(R, Rarray)
    D = np.delete(D, 0, 0)

    MCtotal = RWAccumno + HPAccumno
    SphVol = np.sum((4 / 3) * PI * R ** 3)
    CylVol = PI * (Rout ** 2 - Rin ** 2) * abs(Lend - Lstart)
    ActualPackingFactor = SphVol / CylVol

    if display == 1:
        print(f'Total number of MC Spheres Generated by Hard Packing: {HPAccumno}')
        print(f'Total point loss during Hard Packing: {round((((MCorg) - HPAccumno) / (MCorg)) * 100, 2)} %')
        print(f'Total number of MC Spheres Generated by Random Walking: {RWAccumno}')
        print(f'TOTAL NO OF MC SPHERES GENERATED IN DOMAIN: {MCtotal}')
        print(f'Actual Packing factor {round(ActualPackingFactor, 2)}')

    print(f'>>> MONTE CARLO SPHERE PACKING COMPLETED IN: {round(time.time() - t0, 2)} s<<<<<')
    print("")

    return D, R,ActualPackingFactor,MCtotal

###################################################"""GEN FEM MESH"""###################################################

def lines_from_points(points):
    """Given an array of points, make a line set"""
    poly = pv.PolyData()
    poly.points = points
    cells = np.full((len(points) - 1, 3), 2, dtype=np.int_)
    cells[:, 1] = np.arange(0, len(points) - 1, dtype=np.int_)
    cells[:, 2] = np.arange(1, len(points), dtype=np.int_)
    poly.lines = cells
    return poly




